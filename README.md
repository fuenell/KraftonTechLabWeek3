# WEEK03 4팀 설명 문서

### 4팀: 장수빈, 정찬호, 김진철, 홍신화

### 1. 개요

이번 주차에서는 렌더링 파이프라인을 확장하고 엔진의 핵심 시스템을 구축하는 데 중점을 두었습니다. 주요 구현 사항으로는 텍스처 아틀라스를 이용한 실시간 텍스트 렌더링, 여러 라인 드로우 콜을 하나로 묶어 처리하는 배치 라인 렌더링, 그리고 FName과 UObject 같은 언리얼 엔진의 핵심 개념을 직접 구현한 것입니다. 이를 통해 시각적 표현력을 높이고 엔진의 효율성과 확장성을 개선했습니다.

---

### 2. 주요 기능 상세 설명

### 2.1. Editor & Rendering

### 가. 실시간 문자열 렌더링 (Billboard Text)

- **구현 목표:** 월드에 배치된 UObject의 UUID를 객체 위에 실시간으로 렌더링하여 디버깅 편의성을 높입니다. 텍스트는 항상 카메라를 바라보도록 구현합니다.
- **핵심 원리:**
    - **텍스처 아틀라스:** 모든 ASCII 문자를 한 장의 텍스처(Texture Atlas)에 미리 배치하고, 각 문자에 해당하는 UV 좌표 정보를 `TMap<char, CharacterInfo>`와 같은 자료구조로 관리하여 런타임에 조회합니다.
    - **빌보드 (Screen-Aligned Quad 방식):** 3D 공간에서 카메라를 따라 회전하는 전통적인 빌보드 방식 대신, 오브젝트의 월드 위치를 MVP 행렬을 통해 NDC(Normalized Device Coordinates) 공간으로 변환합니다. 그 후, 변환된 2D 좌표를 기준으로 화면에 직접 사각형(Quad)을 그려 텍스트를 출력합니다. 이 방식은 Vertex Shader에서 복잡한 행렬 곱셈이 필요 없어 효율적입니다.
    - **UV 좌표 조작:** 렌더링할 문자열의 각 문자를 순회하며, 미리 계산된 텍스처 아틀라스의 UV 정보를 이용해 각 문자에 해당하는 텍스처 영역을 화면에 그릴 쿼드에 정확히 매핑합니다.
- **주요 코드/로직:**
    - `ShaderFont.hlsl`: 버텍스 셰이더는 이미 NDC 공간으로 넘어온 정점 위치를 변환 없이 그대로 전달(Pass-through)하는 역할을 합니다. 픽셀 셰이더는 텍스처 아틀라스를 샘플링하고, 배경색에 해당하는 텍셀은 `discard` 하여 글자만 나타나게 합니다.
    - `D3D11_INPUT_ELEMENT_DESC`: 정점 데이터로 3D 위치를 나타내는 `POSITION`과 텍스처 좌표를 위한 `TEXCOORD`를 입력으로 받도록 설정했습니다.
    - **텍스트 정점 생성 로직:** `SetUUIDVertices` 함수가 핵심 역할을 합니다. 이 함수는 오브젝트의 중심점을 MVP 변환하여 NDC 좌표를 얻고, 화면 종횡비(Aspect Ratio)를 고려하여 문자열이 늘어지지 않도록 가로 크기를 보정합니다. 이후 문자열의 각 문자에 대해 4개의 정점과 6개의 인덱스를 생성하여 동적 버퍼에 추가합니다.
- **사용 방법:** Show Flag `SF_BillboardText`의 활성화 여부에 따라 UUID 텍스트 표시를 켜고 끌 수 있습니다.

### 나. 배치 라인(Batch Line) 렌더링

- **구현 목표:** World Grid, Bounding Box 등 다수의 라인 렌더링 요청을 매번 드로우 콜을 호출하는 대신, 하나의 버퍼에 모아서 한 번의 드로우 콜로 처리하여 렌더링 효율을 극대화합니다.
- **핵심 원리:**
    - 프레임이 시작될 때(`BeginFrame`), 라인 정점을 담을 CPU 측 배열을 초기화합니다.
    - `AddLine`과 같은 함수가 호출될 때마다, 라인의 시작점과 끝점 정점 데이터를 하나의 거대한 동적 정점 버퍼(Dynamic Vertex Buffer)에 순차적으로 누적합니다.
    - 모든 라인 정보가 취합되면, 렌더링 직전에 이 데이터를 단 한 번의 `Map/Unmap` 과정을 통해 GPU 버퍼로 전송합니다.
    - 최종적으로 `D3D11_PRIMITIVE_TOPOLOGY_LINELIST` 토폴로지를 사용하여 한 번의 `DrawIndexed` 호출로 모든 라인을 렌더링합니다.
- **주요 기능:**
    - **World Grid:** 월드 공간의 기준이 되는 그리드를 배치 라인 렌더링을 통해 효율적으로 그립니다. ImGui 툴바를 통해 그리드 간격을 동적으로 조절할 수 있습니다.
    - **프리미티브 Bounding Box (AABB):** 각 프리미티브를 감싸는 AABB를 계산하고, Show Flag `SF_Primitives`와 연동하여 필요할 때만 와이어프레임 형태로 렌더링 여부를 제어합니다.

### 다. 좌표계 재정의 및 화면 리사이징

- **구현 목표:** DirectX의 왼손 좌표계(Y-up, Z-forward)를 언리얼 엔진의 왼손 좌표계(Z-up, X-forward) 기준으로 변환하여 사용하고, 윈도우 크기 변경에 실시간으로 대응합니다.
- **핵심 원리:**
    - **좌표계 변환:** 뷰(View) 행렬과 투영(Projection) 행렬을 생성할 때, 축 변환(Z축이 위, X축이 정면)을 선반영하여 카메라와 오브젝트를 제어합니다.
    - **화면 리사이징:** 윈도우 크기가 변경되면 SwapChain의 버퍼 크기를 재조정(`SwapChain->ResizeBuffers()`)합니다. 이후, 기존의 Render Target View(RTV), Depth Stencil View(DSV)를 모두 해제하고 새로운 크기에 맞는 리소스를 다시 생성하여 렌더링 파이프라인에 바인딩합니다. 이 과정에서 화면 종횡비(Aspect Ratio)도 다시 계산하여 투영 행렬 및 UI에 반영합니다.

### 라. 기타 렌더링 기능

- **와이어프레임 뷰 모드:** `D3D11_RASTERIZER_DESC`의 `FillMode`를 `D3D11_FILL_WIREFRAME`으로 설정한 래스터라이저 상태(Rasterizer State)를 추가로 생성했습니다. `EViewModeIndex` 열거형과 ImGui 드롭다운 메뉴를 통해 Lit, Unlit, Wireframe 렌더링 모드를 실시간으로 전환할 수 있도록 구현했습니다.
- **카메라 이동 감도 조절:** ImGui Slider를 통해 카메라의 회전 및 이동 감도를 사용자가 직접 조절하고, 해당 설정값은 `editor.ini` 파일에 저장되어 에디터를 재시작해도 유지되도록 했습니다.

### 2.2. Engine Core

### 가. FName 시스템

- **구현 목표:** 문자열 비교에 드는 비용을 줄이고 메모리 중복을 방지하기 위해, 문자열을 테이블에 저장하고 정수 인덱스로 관리하는 FName 시스템을 구현합니다.
- **핵심 원리:**
    - 엔진 전역에서 사용되는 모든 문자열을 관리하는 정적 해시 테이블(String Pool)을 유지합니다.
    - 새로운 FName 생성 시, 먼저 입력된 문자열을 소문자화하여 테이블에 동일한 문자열이 있는지 확인합니다.
    - 테이블에 문자열이 없으면 원본 문자열과 소문자화된 문자열을 각각 다른 테이블에 새로 추가하고, 해당 문자열의 인덱스를 FName 내부에 저장합니다.
    - FName 간의 비교는 전체 문자열을 비교하는 대신, 미리 계산된 소문자 기준 인덱스(`ComparisonIndex`)를 비교하므로 `O(1)`의 시간 복잡도를 가집니다. 이를 통해 매우 빠른 비교가 가능합니다. 화면에 표시할 때는 원본 대소문자를 보존하는 인덱스(`DisplayIndex`)를 사용합니다.
- **구조체:** C++
    
    ```cpp
    struct FName
    {
        int32 DisplayIndex; // 원본 문자열(대소문자 보존)을 위한 인덱스
        int32 ComparisonIndex; // 비교를 위한 인덱스 (대소문자 통합)
        // ...
    };
    ```
    

### 나. UObject 시스템

- **구현 목표:** 엔진 내 모든 객체를 생성하고 추적하기 위한 최상위 기반 클래스 `UObject`를 정의합니다.
- **핵심 원리:**
    - 모든 UObject는 생성 시 고유한 식별자인 **UUID**를 발급받고, `FName` 시스템을 사용하는 **Name**을 갖습니다.
    - 생성된 모든 UObject는 전역 배열인 `GUObjectArray`에 등록되어 엔진이 모든 객체를 순회하거나 UUID를 통해 빠르게 참조할 수 있습니다.
    - `DECLARE_ROOT_UCLASS`, `DECLARE_UCLASS` 같은 매크로를 통해 RTTI(런타임 타입 정보) 시스템의 기반을 마련했습니다. 이를 통해 `Cast<T>()`, `IsA<T>()` 같은 타입 검사 기능을 제공하고, 향후 리플렉션 시스템으로 확장할 수 있도록 설계했습니다.
    - **객체 관리:** UObject 생성자는 UUID를 발급받고 전역 테이블에 자신을 등록합니다. 소멸자는 테이블의 해당 슬롯을 `nullptr`로 표시하고 인덱스를 재사용 큐에 넣어, 테이블 파편화를 최소화하고 객체 생성/소멸 비용을 `O(1)`에 가깝게 유지합니다.

---
